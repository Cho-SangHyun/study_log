- 자바 7 등장 전에는 데이터 컬렉션(`List`, `Set` 등)을 병렬처리하기 어려웠음.
  - 데이터를 서브파트로 분할하고 서브파트를 각각의 스레드로 할당.. 이때 경쟁상태가 생기지 않도록 적절한 동기화 추가.. 마지막으론 각 서브파트를 연산한 결과 집계 등..
- 이제 `스트림으로 대이터 컬렉션 관련 동작을 쉽게 병렬처리하는 법`에 대해 다룬다.  

<br>  

## 병렬 스트림
- 스트림 요소를 여러 청크(서브파트)로 분할하여 각 스레드에서 쉽게 처리할 수 있도록 하는 스트림
- 컬렉션에 `parallelStream`을 호출하면 생성됨

- 1부터 n까지 수들을 합하는 메서드를 다음과 같이 순차 스트림을 사용하는 형태로 구현했다고 가정해보자.
```java
public long sequentialSum(long n) {
    return Stream.iterate(1L, 1 -> i + 1) // 무한 자연수 스트림 생성
        .limit(n)
        .reduce(0L, Long::sum);
}
```

<br>  

### 순차 스트림을 병렬 스트림으로 변환하기
- 순차 스트림에` parallel` 메서드 호출 시 기존 함수의 리듀싱 연산이 병렬로 처리된다
```java
public long parallelSum(long n) {
    return Stream.iterate(1L, 1 -> i + 1) 
        .limit(n)
        .parallel()  // 병렬 스트림으로 변환
        .reduce(0L, Long::sum);
}
```

- 이렇게 하면 스트림이 여러 청크로 분할되어 리듀싱 연산이 여러 청크에 병렬로 수행되고, 마지막에 각 청크별 연산 결과를 다시 리듀싱 연산으로 합쳐서 전체 스트림의 리듀싱 결과를 뱉어준다
- 순차 스트림에 `parallel`을 호출해도 스트림 자체에는 변화가 없음. 내부적으로 이후 연산이 병렬로 수행되어야 한다는 불리언 플래그만 설정됨
- 반대로 `sequential`을 호출하면 병렬 스트림을 순차 스트림으로 바꿔줄 수 있다
  - 즉 `parallel`과 `sequential`을 조합해 어떤 연산을 병렬로 하고 어떤 연산을 순차로 실행할지 제어 가능

#### 참고
- 리듀싱 과정을 시작하는 시점에 연산을 수행할 전체 목록이 존재해야 청크 분할이 가능
  - 즉 위 코드처럼 `iterate`를 쓰는 경우, `reduce`를 시작하는 시점에 전체 목록이 준비된 게 아님.
- 또한 병렬처리시 오토박싱, 언박싱 비용이 생각보다 부담이 클 수 있다
  - `LongStream.rangeClosed` 같은 기본형 특화 스트림 사용이 큰 혜택을 줄 수 있음

즉 이렇게 해야 똑바로 된 병렬 스트림 처리가 가능하다  
```java
public long parallelSum(long n) {
    return LongStream.rangeClosed(1, n)
        .parallel()
        .reduce(0L, Long::sum);
}
```

<br>  

### 병렬 스트림 효과적으로 쓰기 (주의사항)
- 병렬 스트림으로 써도 되는지 확신이 서지 않는다면? 걍 직접 성능 측정하는게 바람직하다
- 박싱을 주의. 오토박싱과 언박싱은 성능을 크게 저하시키는 요소이므로, 기본형 특화스트림(`IntStream`, `LongStream`) 등을 사용하는게 좋다
- `limit`, `findFirst` 등의 연산은 병렬스트림에서 성능이 더 안 좋으니 주의
  - 뭔가 청크 나눠서 병렬로 처리하기 애매해보이는 연산들
- 소량 데이터 처리에는 병렬 스트림이 애매하다. 오히려 병렬화 과정에서 생기는 연산이 더 비쌀 수도.
- 스트림을 구성하는 자료구조의 적절성을 따져야한다. 예를 들어 `ArrayList`가 `LinkedList`보다 효율적인 분할이 가능
- 최종연산의 병합과정 (예를 들면 `Collector`의 `combiner` 메서드) 비용이 비싼지 살필 것
