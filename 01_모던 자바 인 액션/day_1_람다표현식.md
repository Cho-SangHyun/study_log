### 람다 표현식이란
- 메서드로 전달할 수 있는 익명 함수를 단순화한 것
- 세 부분으로 구성됨

```java
(Person p1, Person p2) -> p1.getAge().compareTo(p2.getAge());
```

1. `(Person p1, Person p2)` : 람다 파라미터 (메서드의 파라미터. 내용물이 없을 수도 있음)
2. `->` : 화살표 (필수
3. `p1.getAge().compareTo(p2.getAge());` : 람다 바디 (람다의 반환값에 해당)

<br/>  

### 람다 활용처
- 함수형 인터페이스(Functional Interface)라는 문맥에서 활용 가능
  - 추상 메서드가 오직 하나인 `인터페이스`. 디폴트 메서드들은 고려 X
  
```java
// sample
@FunctionalInteface           // 함수형 인터페이스임을 가리키는 어노테이션
public interface Adder {
    int add(int a, int b);
}
```
  
- 람다 표현식으로 `함수형 인터페이스의 추상 메서드 구현`을 직접 전달하는 것임
- 즉 람다 표현식은 `함수형 인터페이스의 인스턴스`로 취급(굳이 따지면 인터페이스를 구현한 클래스의 인스턴스)된다

<br/>  

### 함수 디스크립터
- 함수형 인터페이스의 추상 메서드 시그니처가 람다 표현식의 시그니처, 즉 `함수 디스크립터`라 부름 
- `T -> boolean`, `() -> T` 등의 형태

<br/>  

### 람다 활용 : 실행 어라운드 패턴
- 특정 코어 로직 전후로 발생되는 작업(자원 초기화, 반납 등)이 비슷하면 해당 작업 안에 감싸진 코어 로직만 바꿔끼우는 방법을 활용가능한데, 이런 형태를 `실행 어라운드 패턴`이라 함
- 대표적으로 이를 활용한게 `try-with-resources`
- 암튼.. 어떤 작업이 있는데 내부에 감싸진 로직(=동작)을 파라미터화할 수 있다면, 람다를 활용해 로직(=동작)을 전달할 수 있다
  - 람다를 활용해 로직(메서드)를 파라미터로 전달!
- 이때 람다는 함수형 인터페이스라는 문맥에서 활용될 수 있으므로, 해당 작업은 함수형 인터페이스 타입을 파라미터로 작성해야 함
