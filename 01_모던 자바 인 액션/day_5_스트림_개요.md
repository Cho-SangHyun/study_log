## 스트림이란
- 데이터 처리 연산을 지원하도록 Source에서 추출된 연속된 요소
  - 연속된 요소 : 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공
  - Source : 컬렉션, 배열, I/O 자원 등의 데이터 Source로부터 데이터를 소비
  - 데이터 처리 연산 : `filter`, `map` 등의 연산으로 데이터를 조작 가능

<br>  

### 스트림 주요 특징 2가지
1. 파이프라이닝 : 스트림 연산끼리 연결해 커다란 파이프라인 구축 가능
   - 이를 통해 `Laziness`, `Short-circuiting` 같은 최적화도 얻는다
2. 내부 반복 : 반복을 명시적으로 지정(가령 `for`를 사용하는) 안 해도 내부적으로 알아서 반복처리된다는 거
   - 외부 반복 : 사용자가 직접 요소를 반복시키는 거(가령 `for`를 사용하는)
   - 내부 반복은 작업을 병렬로 처리 또는 더 최적화된 다양한 순서로 데이터를 처리 가능하나는 이점을 갖게 해줌
   - 스트림 라이브러리의 내부 반복은 데이터 표현, 하드웨어를 활용한 병렬성 구현을 자동으로 선택 (외부 반복에서 이걸 하려면 직접 `synchronized` 등 써서 해야 함)

<br>  

### 스트림 사용의 장점
1. 선언형으로 컬렉션 데이터 처리 가능 -> 더 간결하고 가독성 좋아질 수 있음
    - `for`, `if` 등의 제어 블록 사용을 통한 동작 구현없이 특정 동작의 수행을 지정하는 형태로 데이터를 처리할 수 있다는 말!
2. 별도의 멀티스레드 코드 없이 데이터를 병렬로 처리 가능 -> 성능 좋아질 수 있음
3. 여러 블록 연산을 연결, 복잡한 데이터 처리 파이프라인을 만들 수 있음 -> 조립가능하다는 것 즉 유연성이 좋아질 수 있음

<br>  

### 스트림과 컬렉션 차이
- 공통점 1 : 둘 다 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공함
- 공통점 2 : 반복자(Iterator)로 순회하는 건 컬렉션에서 한 번만 사용 가능. 새로 순회하려면 new 반복자 만들어야 함. 스트림도 동일하게 한 번 탐색한 걸 다시 순회하려면 Source에서 새 스트림을 다시 만들어야 함
- 가장 큰 차이점 : 컬렉션은 포함된 모든 데이터들을 모두 메모리에 가지고 있는 반면 스트림은 사용하는 영역(범위)의 데이터들만 메모리에 가짐
  - 책에서는 컬렉션은 DVD에 저장된 영화, 스트림은 인터넷을 통해 스트리밍되는 영화에 비유
  - 즉 컬렉션은 모~든 데이터를 미리 계산해서 장전해둔 거고 스트림은 요청할 때만 데이터를 계산해서 장전시키는 것
  - 즉 관점을 달리 해서 보면 스트림은 일종의 pub-sub 관계가 형성됨! (데이터를 요청하는 쪽, 요청된 데이터를 계산해서 장전시키는 쪽..)
 
<br>  

## 스트림 연산
1. 중간 연산 : 연결할 수 있는 스트림 연산. 연산의 결과물도 스트림이라 파이프라이닝 가능한 연산을 말하고 `filter`, `map`, `limit` 등이 해당
2. 최종 연산 : 스트림을 닫는 연산. `count`, `collect` 등이 해당

<br>  

### 중간 연산
- 제일 중요한 특징은 `Lazy`하다는 것
  - 중간 연산만으로는 실제 데이터 처리가 수행되지 않고 최종 연산을 스트림 파이프라인에 실행시키기 전까지는 연산을 지연(lazy)시킨다는 것을 의미
  - 필요한 데이터만 처리하고, 불필요한 연산을 건너뛰기 위해 최소한의 작업만 수행하는 효과를 줌
  - `filter`, `map`, `limit`이 붙어있을 때
    - "1) 필터링하고 2) 그 결과를 map하고 3) 그 결과에서 n개 추려내기" 로 동작하지 않는다
    - 최종 연산이 붙기 전까지는 중간 연산 수행 안함. 최종 연산이 붙어야만 중간 연산들이 수행된다
    - "어차피 연산할 거 미리 하는게 좋지 않음?" 이라는 질문이 올 수 있긴 함. 근데 상황에 따라 "미리 하면 쓸데없이 연산해서 낭비할 뻔한 거 결과가 뭐뭐 필요한지 알고 가니까 쓸데없는 연산 안 하네"가 된다는 거임
